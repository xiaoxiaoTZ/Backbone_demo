{
  "name": "backbone.radio",
  "description": "Messaging patterns for Backbone applications.",
  "homepage": "https://github.com/marionettejs/backbone.radio",
  "version": "2.0.0",
  "main": "build/backbone.radio.js",
  "keywords": [
    "backbone",
    "marionette",
    "decoupled",
    "pubsub",
    "publish",
    "subscribe",
    "messaging",
    "architecture",
    "spa"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/marionettejs/backbone.radio/blob/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "gulp",
    "test-browser": "gulp test-browser",
    "build": "gulp build",
    "coverage": "gulp coverage"
  },
  "author": {
    "name": "Jmeas",
    "email": "jellyes2@gmail.com",
    "url": "http://jmeas.com"
  },
  "bugs": {
    "url": "https://github.com/marionettejs/backbone.radio/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/marionettejs/backbone.radio.git"
  },
  "github": "https://github.com/marionettejs/backbone.radio",
  "peerDependencies": {
    "backbone": "^1.3.3",
    "underscore": "^1.8.3"
  },
  "devDependencies": {
    "babel-core": "6.7.0",
    "babel-eslint": "6.0.4",
    "babel-loader": "6.2.0",
    "babel-polyfill": "6.6.1",
    "babel-preset-es2015": "6.3.13",
    "babel-preset-es2015-rollup": "1.1.1",
    "babel-register": "6.4.3",
    "backbone": ">=1.3.3 <1.4.0",
    "chai": "3.4.1",
    "del": "2.2.0",
    "eslint": "3.2.2",
    "glob": "6.0.3",
    "gulp": "3.9.0",
    "gulp-eslint": "3.0.1",
    "gulp-file": "0.2.0",
    "gulp-filter": "3.0.0",
    "gulp-header": "1.7.1",
    "gulp-istanbul": "0.10.3",
    "gulp-jscs": "3.0.0",
    "gulp-livereload": "3.8.1",
    "gulp-load-plugins": "1.1.0",
    "gulp-mocha": "2.2.0",
    "gulp-plumber": "1.0.1",
    "gulp-rename": "1.2.2",
    "gulp-sourcemaps": "1.6.0",
    "gulp-uglify": "1.5.1",
    "gulp-util": "3.0.7",
    "isparta": "4.0.0",
    "json-loader": "0.5.3",
    "mkdirp": "0.5.1",
    "mocha": "2.3.4",
    "rollup": "0.25.4",
    "rollup-plugin-babel": "2.4.0",
    "sinon": "1.17.2",
    "sinon-chai": "2.8.0",
    "underscore": "1.8.3",
    "webpack": "1.12.9",
    "webpack-stream": "3.1.0"
  },
  "babelBoilerplateOptions": {
    "entryFileName": "backbone.radio",
    "mainVarName": "Backbone.Radio"
  },
  "readme": "# Backbone.Radio\n\n[![Travis Build Status](http://img.shields.io/travis/marionettejs/backbone.radio.svg?style=flat)](https://travis-ci.org/marionettejs/backbone.radio)\n[![Coverage](http://img.shields.io/codeclimate/coverage/github/marionettejs/backbone.radio.svg?style=flat)](https://codeclimate.com/github/marionettejs/backbone.radio)\n[![Dependency Status](http://img.shields.io/david/marionettejs/backbone.radio.svg?style=flat)](https://david-dm.org/marionettejs/backbone.radio)\n[![Gitter chat room](https://img.shields.io/badge/gitter-backbone.radio-brightgreen.svg?style=flat)](https://gitter.im/marionettejs/backbone.radio)\n\n\nBackbone.Radio provides additional messaging patterns for Backbone applications.\n\nBackbone includes an event system, Backbone.Events, which is an implementation of the publish-subscribe pattern. Pub-sub is by far the most\ncommon event pattern in client-side applications, and for good reason: it is incredibly useful. It should also be familiar to web developers\nin particular, because the DOM relies heavily on pub-sub. Consider, for instance, registering a handler on an element's `click` event. This isn't\nso much different than listening to a Model's `change` event, as both of these situations are using pub-sub.\n\nBackbone.Radio adds two additional messaging-related features. The first is Requests, an implementation of the request-reply pattern. Request-reply\nshould also be familiar to web developers, as it's the messaging pattern that backs HTTP communications. The other feature are Channels: explicit\nnamespaces to your communications.\n\n## Installation\n\nClone this repository or install via [Bower](http://bower.io/) or [npm](https://www.npmjs.org/).\n\n```\nbower install backbone.radio\nnpm install backbone.radio\n```\n\nYou must also ensure that Backbone.Radio's dependencies on Underscore (or Lodash) and Backbone are installed.\n\n## Documentation\n\n- [Getting Started](#getting-started)\n  - [Backbone.Events](#backboneevents)\n  - [Radio.Requests](#backboneradiorequests)\n  - [Channels](#channels)\n  - [Using With Marionette](#using-with-marionette)\n- [API](#api)\n  - [Radio.Requests](#requests)\n  - [Channel](#channel)\n  - [Radio](#radio)\n  - [Top-level API](#top-level-api)\n\n## Getting Started\n\n### Backbone.Events\n\nAnyone who has used Backbone should be quite familiar with Backbone.Events. Backbone.Events is what facilitates\ncommunications between objects in your application. The quintessential example of this is listening in on a\nModel's change event.\n\n```js\n// Listen in on a model's change events\nthis.listenTo(someModel, 'change', myCallback);\n\n// Later on, the model triggers a change event when it has been changed\nsomeModel.trigger('change');\n```\n\nLet's look at a diagram for Backbone.Events:\n\n<p align='center'>\n  <img src='https://cloud.githubusercontent.com/assets/10248067/11762943/5a927e54-a0bd-11e5-8aa5-e0fafae0e559.png' alt='Backbone.Events diagram'>\n</p>\n\nIt goes without saying that Backbone.Events is incredibly useful when you mix it into instances of Classes. But what\nif you had a standalone Object with an instance of Backbone.Events on it? This gives you a powerful message bus to utilize.\n\n```js\n// Create a message bus\nvar myBus = _.extend({}, Backbone.Events);\n\n// Listen in on the message bus\nthis.listenTo(myBus, 'some:event', myCallback);\n\n// Trigger an event on the bus\nmyBus.trigger('some:event');\n```\n\nAs long as there was an easy way to access this message bus throughout your entire application, then you would have a central\nplace to store a collection of events.  This is the idea behind Channels. But before we go more into that, let's take a look at Requests.\n\n### Backbone.Radio.Requests\n\nRequests is similar to Events in that it's another event system. And it has a similar API, too. For this reason, you *could* mix\nit into an object.\n\n```js\n_.extend(myView, Backbone.Radio.Requests);\n```\n\nAlthough this works, I wouldn't recommend it. Requests are most useful, I think, when they're used with a Channel.\n\nPerhaps the biggest difference between Events and Requests is that Requests have *intention*. Unlike Events, which notify\nnothing in particular about an occurrence, Requests are asking for a very specific thing to occur. As a consequence of this,\nrequests are 'one-to-one,' which means that you cannot have multiple 'listeners' to a single request.\n\nLet's look at a basic example.\n\n```js\n// Set up an object to reply to a request. In this case, whether or not its visible.\nmyObject.reply('visible', this.isVisible);\n\n// Get whether it's visible or not.\nvar isViewVisible = myObject.request('visible');\n```\n\nThe handler in `reply` can either return a flat value, like `true` or `false`, or a function to be executed. Either way, the value is sent back to\nthe requester.\n\nHere's a diagram of the Requests pattern:\n\n<p align='center'>\n  <img src='https://cloud.githubusercontent.com/assets/10248067/11762945/5c302a36-a0bd-11e5-8e4e-0eee7cacbef1.png' alt='Backbone.Requests diagram'>\n</p>\n\nAlthough the name is 'Requests,' you can just as easily request information as you can request that an action be completed. Just like HTTP,\nwhere you can both make GET requests for information, or DELETE requests to order than a resource be deleted, Requests can be used for a variety\nof purposes.\n\nOne thing to note is that this pattern is **identical** to a simple method call. One can just as easily rewrite the above example as:\n\n```js\n// Set up a method...\nmyObject.isVisible = function() {\n  return this.viewIsVisible;\n}\n\n// Call that method\nvar isViewVisible = myObject.isVisible();\n```\n\nThis is why mixing Requests into something like a View or Model does not make much sense. If you have access to the View or Model, then\nyou might as well just use methods.\n\n### Channels\n\nThe real draw of Backbone.Radio are Channels. A Channel is simply an object that has Backbone.Events and Radio.Requests mixed into it:\nit's a standalone message bus comprised of both systems.\n\nGetting a handle of a Channel is easy.\n\n```js\n// Get a reference to the channel named 'user'\nvar userChannel = Backbone.Radio.channel('user');\n```\n\nOnce you've got a channel, you can attach handlers to it.\n\n```js\nuserChannel.on('some:event', function() {\n  console.log('An event has happened!');\n});\n\nuserChannel.reply('some:request', 'food is good');\n```\n\nYou can also use the 'trigger' methods on the Channel.\n\n```js\nuserChannel.trigger('some:event');\n\nuserChannel.request('some:request');\n```\n\nYou can have as many channels as you'd like\n\n```js\n// Maybe you have a channel for the profile section of your app\nvar profileChannel = Backbone.Radio.channel('profile');\n\n// And another one for settings\nvar settingsChannel = Backbone.Radio.channel('settings');\n```\n\nThe whole point of Channels is that they provide a way to explicitly namespace events in your application, and a means to easily access\nany of those namespaces.\n\n### Using With Marionette\n\n[Marionette](https://github.com/marionettejs/backbone.marionette) does not use Radio by default, although it will in the next major release: v3. However, you can use Radio today by including a small shim after you load Marionette, but before you load your application's code. To get the shim, refer to [this Gist](https://gist.github.com/jmeas/7992474cdb1c5672d88b).\n\n## API\n\nLike Backbone.Events, **all** of the following methods support both the object-syntax and space-separated syntax. For the sake of brevity,\nI only provide examples for these alternate syntaxes in the most common use cases.\n\n### Requests\n\n#### `request( requestName [, args...] )`\n\nMake a request for `requestName`. Optionally pass arguments to send along to the callback. Returns the reply, if one\nexists. If there is no reply registered then `undefined` will be returned.\n\nYou can make multiple requests at once by using the space-separated syntax.\n\n```js\nmyChannel.request('requestOne requestTwo');\n```\n\nWhen using the space-separated syntax, the responses will be returned to you as an object, where\nthe keys are the name of the request, and the values are the replies.\n\n#### `reply( requestName, callback [, context] )`\n\nRegister a handler for `requestName` on this object. `callback` will be executed whenever the request is made. Optionally\npass a `context` for the callback, defaulting to `this`.\n\nTo register a default handler for Requests use the `default` requestName. The unhandled `requestName` will be passed as the first argument.\n\n```js\nmyChannel.reply('default', function(requestName) {\n  console.log('No reply exists for this request: ' + requestName);\n});\n\n// This will be handled by the default request\nmyChannel.request('someUnhandledRequest');\n```\n\nTo register multiple requests at once you may also pass in a hash.\n\n```js\n// Connect all of the replies at once\nmyChannel.reply({\n  'some:request': myCallback,\n  'some:other:request': someOtherCallback\n}, context);\n```\n\nReturns the instance of Requests.\n\n#### `replyOnce( requestName, callback [, context] )`\n\nRegister a handler for `requestName` that will only be called a single time.\n\nLike `reply`, you may also pass a hash of replies to register many at once. Refer to the `reply` documentation above\nfor an example.\n\nReturns the instance of Requests.\n\n#### `stopReplying( [requestName] [, callback] [, context] )`\n\nIf `context` is passed, then all replies with that context will be removed from the object. If `callback` is\npassed then all requests with that callback will be removed. If `requestName` is passed then this method will\nremove that reply. If no arguments are passed then all replies are removed from the object.\n\nYou may also pass a hash of replies or space-separated replies to remove many at once.\n\nReturns the instance of Requests.\n\n### Channel\n\n#### `channelName`\n\nThe name of the channel.\n\n#### `reset()`\n\nDestroy all handlers from Backbone.Events and Radio.Requests from the channel. Returns the channel.\n\n### Radio\n\n#### `channel( channelName )`\n\nGet a reference to a channel by name. If a name is not provided an Error will be thrown.\n\n```js\nvar authChannel = Backbone.Radio.channel('auth');\n```\n\n#### `DEBUG`\n\nThis is a Boolean property. Setting it to `true` will cause console warnings to be issued\nwhenever you interact with a `request` that isn't registered. This is useful in development when you want to\nensure that you've got your event names in order.\n\n```js\n// Turn on debug mode\nBackbone.Radio.DEBUG = true;\n\n// This will log a warning to the console if it goes unhandled\nmyChannel.request('show:view');\n\n// Likewise, this will too, helping to prevent memory leaks\nmyChannel.stopReplying('startTime');\n```\n\n#### `debugLog(warning, eventName, channelName)`\n\nA function executed whenever an unregistered request is interacted with on a Channel. Only\ncalled when `DEBUG` is set to `true`. By overriding this you could, for instance, make unhandled\nevents throw Errors.\n\nThe warning is a string describing the type of problem, such as:\n\n> Attempted to remove the unregistered request\n\nwhile the `eventName` and `channelName` are what you would expect.\n\n#### `tuneIn( channelName )`\n\nTuning into a Channel is another useful tool for debugging. It passes all\ntriggers and requests made on the channel to\n\n[`Radio.log`](https://github.com/jmeas/backbone.radio#log-channelname-eventname--args-).\nReturns `Backbone.Radio`.\n\n```js\nBackbone.Radio.tuneIn('calendar');\n```\n\n#### `tuneOut( channelName )`\n\nOnce you're done tuning in you can call `tuneOut` to stop the logging. Returns `Backbone.Radio`.\n\n```js\nBackbone.Radio.tuneOut('calendar');\n```\n\n#### `log( channelName, eventName [, args...] )`\n\nWhen tuned into a Channel, this method will be called for all activity on\na channel. The default implementation is to `console.log` the following message:\n\n```js\n'[channelName] \"eventName\" args1 arg2 arg3...'\n```\n\nwhere args are all of the arguments passed with the message. It is exposed so that you\nmay overwrite it with your own logging message if you wish.\n\n### 'Top-level' API\n\nIf you'd like to execute a method on a channel, yet you don't need to keep a handle of the\nchannel around, you can do so with the proxy functions directly on the `Backbone.Radio` object.\n\n```js\n// Trigger 'some:event' on the settings channel\nBackbone.Radio.trigger('settings', 'some:event');\n```\n\nAll of the methods for both messaging systems are available from the top-level API.\n\n#### `reset( [channelName] )`\n\nYou can also reset a single channel, or all Channels, from the `Radio` object directly. Pass a\n`channelName` to reset just that specific channel, or call the method without any arguments\nto reset every channel.\n\n```js\n// Reset all channels\nRadio.reset();\n```\n",
  "readmeFilename": "README.md",
  "_id": "backbone.radio@2.0.0",
  "dist": {
    "shasum": "1e5666606d156ab20dffbc8d43e6654630f93eb6"
  },
  "_from": "backbone.radio@^2.0.0",
  "_resolved": "https://registry.npmjs.org/backbone.radio/-/backbone.radio-2.0.0.tgz"
}
